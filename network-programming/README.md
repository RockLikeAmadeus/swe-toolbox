The network is hardware, and in non-embedded systems, we can only access the hardware _through the OS_. Unix systems expose the [sockets API](https://beej.us/guide/bgnet/) to C programs (there are equivalents for other operating systems). Other languages might provide direct translation to the C API, or might wrap it into a higher abstraction level, for communicating over the network. Python defines the [socket](https://docs.python.org/3/library/socket.html) library which provides "a straightforward transliteration of the Unix system call and library interface for sockets to Pythonâ€™s object-oriented style", making it a common choice for network programming when we don't want to work at a higher level than raw C demands.

Although there exists the [OSI model](https://en.wikipedia.org/wiki/OSI_model), for most real-world purposes the simplified [internet layer model](https://en.wikipedia.org/wiki/Internet_layer), which contains just four layers, is just as if not more useful. When doing network programming, it's important to ask what layer we are concerned with, and in most cases we're working at the application layer (FTP, HTTP). If we're communicating between systems that define their own protocols, we're probably implementing those protocols on top of the transport layer (TCP, UDP), and are unlikely to need to go deeper than that.