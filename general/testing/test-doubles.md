Source: https://blog.cleancoder.com/uncle-bob/2014/05/14/TheLittleMocker.html
The examples are taken directly from here. Before publishing this information anywhere but here, re-write the examples.

# Overview

Test doubles are used as stand-ins for the dependencies of units we are testing. Take a look at this simple interface:

```
interface Authorizer {
  public Boolean authorize(String username, String password);
}
```

Then imagine a system under test that accepts this an instance of this interface as a dependency, like this:

```
public class System {
  public System(Authorizer authorizer) {
	this.authorizer = authorizer;
  }

  public int loginCount() {
	//returns number of logged in users.
  }
}
```

We would want to use a test double in order to exercise `System` without needing to use a production implementation of Authorizer, like this:

```
@Test
  public void newlyCreatedSystem_hasNoLoggedInUsers() {
	System system = new System(new DummyAuthorizer());
	assertThat(system.loginCount(), is(0));
}
```

A "dummy" is only one kind of test double. See others below. **Examples will assume the `Authorizer` interface defined above.**

# Types of Test Doubles

A useful way to think about these is that a *mock* is a kind of *spy*, a *spy* is a kind of *stub*, and a *stub* is a kind of *dummy*. A *fake* is really in its own class. Unless you need a fake, it probably makes sense to use a *dummy* if you can, a *stub* if you can't use a dummy, a *spy* if you can't use a stub, and a *mock* if you can't use a spy.

dummy -> stub -> spy -> mock

Uncle Bob suggests using **stubs** and **spies** mostly, and rarely using dummies. You should only use mocks if you're using a mocking tool (and you usually don't need to use a mocking tool), and try to avoid using fakes alltogether, if possible. IDEs should have a way to automatically implement a dummy from an interface; manually transforming that dummy into a stub or a spy should be pretty straightforward.

## Dummy

### Example

```
public class DummyAuthorizer implements Authorizer {
  public Boolean authorize(String username, String password) {
	return null;
  }
}
```

A dummy is ideal when you don't care how or if a dependency is used. This is (I think) for cases where the unit under test requires a dependency, but nothing about that dependency is what's really being tested. Dummy implementations probably should just return null where possible, because we don't want dummy implementations to be used at all (if they are, we'll get a null reference exception, which tells us the method is being used but shouldn't be).

## Stub

### Example

```
public class AcceptingAuthorizerStub implements Authorizer {
  public Boolean authorize(String username, String password) {
	return true;
  }
}
```

Stubs are kind of like dummies, but we _do_ expect their implementations to be used. Those implementations should just return hard-coded values, however.

## Spy

### Example

```
public class AcceptingAuthorizerSpy implements Authorizer {
  public boolean authorizeWasCalled = false;

  public Boolean authorize(String username, String password) {
	authorizeWasCalled = true;
	return true;
  }
}
```

We use a spy when we want to examine how a dependency is used by the system under test. They can report details such as whether a method was called, how many times a method is called, or what arguments were passed to a function. Care is required when using spies, since too much spying tightly couples your tests to the implementations, which leads to fragile tests.

## Mock

### Example

```
public class AcceptingAuthorizerVerificationMock implements Authorizer {
  public boolean authorizeWasCalled = false;

  public Boolean authorize(String username, String password) {
	authorizeWasCalled = true;
	return true;
  }

  public boolean verify() {
	return authorizedWasCalled;
  }
}
```

Mocks are spies that _know_ what they are testing. A mock is interested in the usage of the dependency, but unlike a regular spy, a mock *knows what to expect*. Using this type of test double adds even more coupling, but the main benefit is that it makes it easier to develop mocking *tools*. In reality, mocks should only be used when generated by mocking tools.

## Fake

### Example

```
public class AcceptingAuthorizerFake implements Authorizer {
  public Boolean authorize(String username, String password) {
	return username.equals("Bob");
  }
}
```

A fake is kind of like a simulator. Unlike any of the other types of test doubles, fakes have real business behavior, which makes them different at a fundamental level. They can also get so complicated that they require tests of their own. At the extremes, the fake becomes the real system. Uncle Bob claims in his blog to not have written one for over thirty years.
